#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    printf "${1}${2}${NC}\n"
}

# Function to get the latest tag (excluding 'latest')
get_latest_tag() {
    # Get all tags, filter out 'latest', sort by version, and get the most recent
    git tag -l | grep -v '^latest$' | grep '^v[0-9]' | sort -V | tail -n 1 || echo "v0.0.0"
}

# Function to parse version components
parse_version() {
    local version=$1
    # Remove 'v' prefix if present
    version=${version#v}
    IFS='.' read -r major minor patch <<< "$version"
    echo "$major $minor $patch"
}

# Function to increment version
increment_version() {
    local major=$1
    local minor=$2
    local patch=$3
    local increment_type=$4

    case $increment_type in
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        patch)
            patch=$((patch + 1))
            ;;
        *)
            print_color $RED "Invalid increment type: $increment_type"
            exit 1
            ;;
    esac

    echo "$major.$minor.$patch"
}

# Function to get current version from version.go
get_current_version() {
    grep "const VERSION" version.go | sed "s/.*VERSION = \"\([^\"]*\)\".*/\1/"
}

# Function to update version files
update_version_files() {
    local version=$1

    print_color $BLUE "Updating version files to $version..."

    # Update version.go
    cat > version.go << EOF
// This file is auto-generated by the release script
// Do not modify manually
package main

const VERSION = "$version"
EOF

    # Update go.mod version comment (add version comment if needed)
    if ! grep -q "// version:" go.mod; then
        sed -i "1a\\// version: $version" go.mod
    else
        sed -i "s|// version:.*|// version: $version|" go.mod
    fi

    print_color $GREEN "‚úÖ Version files updated to $version"
}

# Main script
print_color $BLUE "üöÄ SatHub Client Release Script"
echo

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_color $RED "Error: Not in a git repository"
    exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    print_color $RED "Error: You have uncommitted changes. Please commit or stash them first."
    exit 1
fi

# Get latest tag
latest_tag=$(get_latest_tag)
print_color $GREEN "Current latest tag: $latest_tag"

# Parse version
read -r major minor patch <<< "$(parse_version "$latest_tag")"
print_color $BLUE "Current version: $major.$minor.$patch"

# Ask for increment type
echo
print_color $YELLOW "What type of release would you like to make?"
echo "1) Patch (bug fixes) - $major.$minor.$((patch + 1))"
echo "2) Minor (new features) - $major.$((minor + 1)).0"
echo "3) Major (breaking changes) - $((major + 1)).0.0"
echo "4) Tag only (use existing version from files, no version update)"
echo "5) Create release for current latest tag (no new tag)"
echo
read -p "Enter your choice (1-5): " choice

case $choice in
    1)
        new_version=$(increment_version "$major" "$minor" "$patch" "patch")
        update_versions=true
        create_new_tag=true
        ;;
    2)
        new_version=$(increment_version "$major" "$minor" "$patch" "minor")
        update_versions=true
        create_new_tag=true
        ;;
    3)
        new_version=$(increment_version "$major" "$minor" "$patch" "major")
        update_versions=true
        create_new_tag=true
        ;;
    4)
        new_version=$(get_current_version)
        update_versions=false
        create_new_tag=true
        print_color $BLUE "Using existing version from files: $new_version"
        ;;
    5)
        new_version="$major.$minor.$patch"
        update_versions=false
        create_new_tag=false
        print_color $BLUE "Will create release for existing tag: v$new_version"
        ;;
    *)
        print_color $RED "Invalid choice. Exiting."
        exit 1
        ;;
esac

new_tag="v$new_version"

# Handle tag creation
if [ "$create_new_tag" = true ]; then
    print_color $GREEN "New tag will be: $new_tag"

    # Handle version file updates based on the choice
    if [ "$update_versions" = true ]; then
        # Ask about updating version files
        echo
        read -p "Would you like to update version files and commit them before creating the tag? (Y/n): " update_files_confirm
        if [[ ! $update_files_confirm =~ ^[Nn]$ ]]; then
            update_version_files "$new_version"

            # Check if there are changes to commit
            if ! git diff-index --quiet HEAD --; then
                print_color $BLUE "Committing version updates..."
                git add version.go go.mod
                git commit -m "chore: bump version to $new_version"

                # Ask if we should push the commit
                read -p "Push the version commit to origin? (Y/n): " push_commit
                if [[ ! $push_commit =~ ^[Nn]$ ]]; then
                    git push origin $(git rev-parse --abbrev-ref HEAD)
                    print_color $GREEN "‚úÖ Version commit pushed"
                fi
            else
                print_color $YELLOW "No changes to commit (version files already up to date)"
            fi
        fi
    else
        print_color $BLUE "Skipping version file updates as requested"
    fi

    # Confirm
    echo
    read -p "Are you sure you want to create and push tag $new_tag? (y/N): " confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        print_color $YELLOW "Release cancelled."
        exit 0
    fi

    # Create and push tag
    print_color $BLUE "Creating tag $new_tag..."
    git tag -a "$new_tag" -m "Release $new_tag"

    print_color $BLUE "Pushing tag $new_tag..."
    git push origin "$new_tag"

    print_color $GREEN "‚úÖ Tag $new_tag created and pushed successfully!"

    # Update 'latest' tag
    print_color $BLUE "Updating 'latest' tag..."
    git tag -fa latest -m "Latest release: $new_tag"
    git push origin latest --force

    print_color $GREEN "‚úÖ 'latest' tag updated and pushed!"
else
    print_color $BLUE "Skipping tag creation (will create release for existing tag: $new_tag)"

    # Verify the tag exists
    if ! git rev-parse "$new_tag" >/dev/null 2>&1; then
        print_color $RED "‚ùå Error: Tag $new_tag does not exist!"
        exit 1
    fi
fi

# Ask about creating a release
echo
if [ "$create_new_tag" = false ]; then
    # For option 5, default to yes for creating release
    read -p "Would you like to create a GitHub release for $new_tag? (Y/n): " create_release
    create_release_default="y"
else
    read -p "Would you like to create a GitHub release now? (y/N): " create_release
    create_release_default="n"
fi

if [[ $create_release =~ ^[Yy]$ ]] || [[ -z $create_release && $create_release_default == "y" ]]; then
    print_color $BLUE "Creating GitHub release for $new_tag..."
    print_color $YELLOW "Note: Client binaries will be built automatically by GitHub Actions CI"

    # Check if GitHub CLI is available
    if ! command -v gh > /dev/null; then
        print_color $RED "‚ùå GitHub CLI (gh) is not installed. Please install it first:"
        echo "  https://cli.github.com/"
        print_color $YELLOW "You can still create the release manually at:"
        echo "  https://github.com/vleeuwenmenno/sathub-client/releases/new?tag=$new_tag"
        exit 1
    fi

    # Check if user is authenticated with GitHub CLI
    if ! gh auth status > /dev/null 2>&1; then
        print_color $RED "‚ùå Not authenticated with GitHub CLI. Please run 'gh auth login' first"
        exit 1
    fi

    # Check if release already exists
    if gh release view "$new_tag" >/dev/null 2>&1; then
        print_color $YELLOW "‚ö†Ô∏è  Release $new_tag already exists"
        read -p "Do you want to delete and recreate it? (y/N): " recreate
        if [[ $recreate =~ ^[Yy]$ ]]; then
            print_color $BLUE "Deleting existing release..."
            gh release delete "$new_tag" --yes
        else
            print_color $YELLOW "Release creation cancelled."
            exit 0
        fi
    fi

    # Get release notes from CHANGELOG.md or git log
    release_notes=""
    if [ -f "CHANGELOG.md" ]; then
        # Try to extract notes for this version from CHANGELOG
        release_notes=$(sed -n "/## \[$new_version\]/,/## \[/p" CHANGELOG.md | sed '$d' | sed '1d')
    fi

    if [ -z "$release_notes" ]; then
        # Fallback to recent commits
        prev_tag=$(git tag -l | grep -v '^latest$' | grep '^v[0-9]' | sort -V | tail -n 2 | head -n 1)
        if [ -n "$prev_tag" ]; then
            release_notes="## What's Changed

$(git log --oneline --pretty=format:"- %s" ${prev_tag}..${new_tag})"
        else
            release_notes="## What's Changed

Initial release"
        fi
    fi

    # Create the release (without assets - CI will add them)
    # Use printf to properly handle newlines in release notes
    if printf "%s" "$release_notes" | gh release create "$new_tag" --title "$new_tag" --notes-file - --generate-notes; then
        print_color $GREEN "‚úÖ GitHub release created successfully!"
        print_color $BLUE "Release URL: https://github.com/vleeuwenmenno/sathub-client/releases/tag/$new_tag"
        print_color $YELLOW "CI will automatically build and attach client binaries..."
    else
        print_color $RED "‚ùå Failed to create GitHub release"
        print_color $YELLOW "You can create it manually at:"
        echo "  https://github.com/vleeuwenmenno/sathub-client/releases/new?tag=$new_tag"
        exit 1
    fi
else
    print_color $BLUE "You can create a release later at: https://github.com/vleeuwenmenno/sathub-client/releases/new?tag=$new_tag"
fi

print_color $GREEN "üéâ Client release process complete!"